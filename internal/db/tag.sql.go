// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tag.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTagKey = `-- name: CreateTagKey :one
INSERT INTO tag_keys (team_id, name, data_type) VALUES ($1, $2, $3) RETURNING id, team_id, name, data_type, created_at
`

type CreateTagKeyParams struct {
	TeamID   int32       `json:"team_id"`
	Name     string      `json:"name"`
	DataType TagDataType `json:"data_type"`
}

func (q *Queries) CreateTagKey(ctx context.Context, arg CreateTagKeyParams) (TagKey, error) {
	row := q.db.QueryRow(ctx, createTagKey, arg.TeamID, arg.Name, arg.DataType)
	var i TagKey
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Name,
		&i.DataType,
		&i.CreatedAt,
	)
	return i, err
}

const createTagValue = `-- name: CreateTagValue :one
INSERT INTO tag_values (key_id, value) VALUES ($1, $2) RETURNING id, key_id, value, created_at
`

type CreateTagValueParams struct {
	KeyID int32  `json:"key_id"`
	Value string `json:"value"`
}

func (q *Queries) CreateTagValue(ctx context.Context, arg CreateTagValueParams) (TagValue, error) {
	row := q.db.QueryRow(ctx, createTagValue, arg.KeyID, arg.Value)
	var i TagValue
	err := row.Scan(
		&i.ID,
		&i.KeyID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTagKey = `-- name: DeleteTagKey :one
DELETE FROM tag_keys WHERE id = $1 RETURNING id, team_id, name, data_type, created_at
`

func (q *Queries) DeleteTagKey(ctx context.Context, id int32) (TagKey, error) {
	row := q.db.QueryRow(ctx, deleteTagKey, id)
	var i TagKey
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Name,
		&i.DataType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTagValue = `-- name: DeleteTagValue :one
DELETE FROM tag_values WHERE id = $1 RETURNING id, key_id, value, created_at
`

func (q *Queries) DeleteTagValue(ctx context.Context, id int32) (TagValue, error) {
	row := q.db.QueryRow(ctx, deleteTagValue, id)
	var i TagValue
	err := row.Scan(
		&i.ID,
		&i.KeyID,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const listFilters = `-- name: ListFilters :many
SELECT
  k.id AS key_id,
  k.name AS key,
  sv.id AS value_id,
  sv.value AS value,
  JSONB_AGG(
    JSONB_BUILD_OBJECT(
      'id', v.id,
      'value', v.value
    )
    ORDER BY v.value
  ) FILTER (WHERE v.id IS NOT NULL) AS options
  FROM tag_keys k
  LEFT JOIN member_filters f ON f.key_id = k.id AND f.membership_id = $1
  LEFT JOIN tag_values sv ON sv.id = f.value_id
  LEFT JOIN tag_values v ON v.key_id = k.id
  GROUP BY k.id, k.name, sv.id, sv.value
`

type ListFiltersRow struct {
	KeyID   int32       `json:"key_id"`
	Key     string      `json:"key"`
	ValueID pgtype.Int4 `json:"value_id"`
	Value   pgtype.Text `json:"value"`
	Options []byte      `json:"options"`
}

func (q *Queries) ListFilters(ctx context.Context, membershipID int32) ([]ListFiltersRow, error) {
	rows, err := q.db.Query(ctx, listFilters, membershipID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFiltersRow
	for rows.Next() {
		var i ListFiltersRow
		if err := rows.Scan(
			&i.KeyID,
			&i.Key,
			&i.ValueID,
			&i.Value,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTagKey = `-- name: UpdateTagKey :one
UPDATE tag_keys SET name = $2, data_type = $3 WHERE id = $1 RETURNING id, team_id, name, data_type, created_at
`

type UpdateTagKeyParams struct {
	ID       int32       `json:"id"`
	Name     string      `json:"name"`
	DataType TagDataType `json:"data_type"`
}

func (q *Queries) UpdateTagKey(ctx context.Context, arg UpdateTagKeyParams) (TagKey, error) {
	row := q.db.QueryRow(ctx, updateTagKey, arg.ID, arg.Name, arg.DataType)
	var i TagKey
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.Name,
		&i.DataType,
		&i.CreatedAt,
	)
	return i, err
}
